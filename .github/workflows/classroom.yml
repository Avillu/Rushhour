name: Test de laboratorio SI
on:
- repository_dispatch
permissions:
  checks: write
  actions: read
  contents: read


jobs:
  run-autograding-tests:
    #env:
    # TESTS_ACTIVOS: '["T1", "T2"]'  # Configura aqu√≠ qu√© tests ejecutar

    runs-on: ubuntu-latest
    if: github.actor != 'github-classroom[bot]'
    steps:

    # üö´ NUEVO PASO A√ëADIDO PARA BLOQUEAR REEJECUCIONES
      - name: üö´ Bloquear Reejecuci√≥n
        run: |
          echo "Intento de Ejecuci√≥n: $GITHUB_RUN_ATTEMPT"
          if [ "$GITHUB_RUN_ATTEMPT" -gt 1 ]; then
            echo "üö® ¬°ERROR! Esta es una reejecuci√≥n ('Rerun'). Se anula la ejecuci√≥n de este job."
            exit 1  # Provoca que el job falle inmediatamente
          fi
          echo "‚úÖ Primera ejecuci√≥n. Continuamos."

      - name: Checkout alumno
        uses: actions/checkout@v4

      - name: Checkout tests (SI-25-Talavera/test2025)
        uses: actions/checkout@v4
        with:
          repository: SI-25-Talavera/test2025
          ref: main
          path: test
          ssh-key: ${{ secrets.TOKEN_OK }}

      - name: Obtener path absoluto del repo test
        id: test_path
        run: echo "path=$(realpath test)" >> $GITHUB_OUTPUT


      - name: Leer y validar variables desde test.txt
        id: leer
        run: |
          # Comprobar si test.txt existe
          if [ ! -f test.txt ]; then
            echo "‚ùå Error: El fichero test.txt no existe."
            exit 1
          fi

          # Leer l√≠neas 1 y 2
          LENGUAJE=$(sed -n '1p' test.txt)
          PATHTEST=$(sed -n '2p' test.txt)
          PROGRAMA=$(sed -n '1p' test/programa.txt) # Leer nombre del programa desde test/programa.txt
          VALOR_TEST="$(tr -d '\n\r' < test/test_activos.json)"
          echo "TESTS_ACTIVOS=${VALOR_TEST}" >> $GITHUB_ENV


          # Limpiar el lenguaje: quitar espacios, pasar a may√∫sculas
          LENGUAJE=$(echo "$LENGUAJE" | tr -d '[:space:]' | tr '[:lower:]' '[:upper:]')

          # Validar lenguaje permitido
          case "$LENGUAJE" in
            JAVA|PYTHON|BIN)
              echo "‚úÖ Lenguaje v√°lido: $LENGUAJE"
              ;;
            *)
              echo "‚ùå Error: Lenguaje '$LENGUAJE' no permitido. Debe ser JAVA, PYTHON o BIN."
              exit 1
              ;;
          esac

          # Verificar que el path no est√© vac√≠o
          if [ -z "$PATHTEST" ]; then
            echo "‚ùå Error: El path de test est√° vac√≠o en test.txt."
            exit 1
          fi

          # Normalizar path (eliminar espacios y './' inicial si existe)
          PATHTEST=$(echo "$PATHTEST" | xargs)          # quita espacios al inicio y fin
          PATHTEST=$(echo "$PATHTEST" | sed 's|^\./||') # quita './' inicial

          # Validar que el directorio existe
          if [ ! -d "$PATHTEST" ]; then
            echo "‚ùå Error: La carpeta '$PATHTEST' no existe en el repositorio."
            echo "Ruta actual: $(pwd)"
            exit 1
          fi

          # Definir comando de ejecuci√≥n seg√∫n lenguaje

          case "$LENGUAJE" in
            PYTHON) 
              COMMAND="${PROGRAMA}.py"
              ;;

            JAVA)
              COMMAND="${PROGRAMA}.jar"
              ;;

            BIN)
              COMMAND="${PROGRAMA}"
              ;;

            *)
              echo "Lenguaje no soportado: $LENGUAJE (usa PYTHON|JAVA|BIN)" >&2
              exit 1
              ;;
          esac

          # Exportar variables para el resto del workflow # Exportar variables para los siguientes steps
          echo "lenguaje=$LENGUAJE" >> $GITHUB_OUTPUT
          echo "pathtexec=$PATHTEST" >> $GITHUB_OUTPUT
          echo "pathtest=test" >> $GITHUB_OUTPUT
          echo "programa=$PROGRAMA" >> $GITHUB_OUTPUT
          echo "command=$COMMAND" >> $GITHUB_OUTPUT
          echo "pathtest=test" >> $GITHUB_OUTPUT
          echo "programa=$PROGRAMA" >> $GITHUB_OUTPUT
          echo "command=$COMMAND" >> $GITHUB_OUTPUT

          echo "‚úÖ Variables finales:"
          echo "LENGUAJE=$LENGUAJE"
          echo "PATHEXEC=$PATHTEST"
          echo "TEST_ACTIVOS=$TEST_ACTIVOS"


      - name: Obtener todas las carpetas absolutas de test
        id: carpetas
        run: |
          set -euo pipefail
          # Obtener path raiz del repo test
          PATH_RAIZ="${GITHUB_WORKSPACE}"
          PATH_EXEC="${PATH_RAIZ}/${{ steps.leer.outputs.pathtexec }}"
          PATH_TEST="${PATH_RAIZ}/test"
          PATH_SCRIPTS="${PATH_RAIZ}/test/script"
          PATH_CLASSROOM="${PATH_RAIZ}/.github/classroom"
          # exportamos las variable al resto del workflow
          echo "raiz=$PATH_RAIZ" >> $GITHUB_OUTPUT
          echo "exec=$PATH_EXEC" >> $GITHUB_OUTPUT
          echo "test=$PATH_TEST" >> $GITHUB_OUTPUT
          echo "scripts=$PATH_SCRIPTS" >> $GITHUB_OUTPUT
          echo "classroom=$PATH_CLASSROOM" >> $GITHUB_OUTPUT
          


      - name: A√±adimos utilidades genericas
        run: |
          #sudo apt-get update -y
          sudo apt-get install -y jq #dos2unix coreutils

      # Requiere que antes hayas definido LENGUAJE (JAVA/PYTHON/GO) y, opcionalmente, PATHTEST

      - name: Instalar Java (si LENGUAJE=JAVA)
        if: ${{ steps.leer.outputs.lenguaje == 'JAVA' }}
        run: |
          sudo apt install -y wget apt-transport-https gpg
          wget -qO - https://packages.adoptium.net/artifactory/api/gpg/key/public \
          | gpg --dearmor \
          | sudo tee /etc/apt/trusted.gpg.d/adoptium.gpg > /dev/null

            # 2) A√±adir el repo de Adoptium (detecta autom√°ticamente tu codename de Ubuntu)
          echo "deb https://packages.adoptium.net/artifactory/deb $(. /etc/os-release; echo $VERSION_CODENAME) main" \
          | sudo tee /etc/apt/sources.list.d/adoptium.list

            # 3) Instalar la √∫ltima LTS (Java 25) del JDK
          sudo apt-get update
          sudo apt-get install -y temurin-25-jdk
          sudo update-alternatives --set java  /usr/lib/jvm/temurin-25-jdk-amd64/bin/java
          sudo update-alternatives --set javac /usr/lib/jvm/temurin-25-jdk-amd64/bin/javac

          java -version

      - name: Instalar dependencias Python (si LENGUAJE=PYTHON)
        if: ${{ steps.leer.outputs.lenguaje == 'PYTHON' }}
        run: |
          python3 -V || sudo apt-get update && sudo apt-get install -y python3 python3-pip
          python3 -m pip install --upgrade pip

          # Detectar el requirements.txt (ra√≠z o dentro de $PATHTEST)
          PATHTEST=${{ steps.leer.outputs.pathtest }}
          if [ -f ${{steps.carpetas.outputs.exec}}/requirements.txt ]; then
            echo "üì¶ Instalando dependencias desde requirements"
            python3 -m pip install -r ${{steps.carpetas.outputs.exec}}/requirements.txt
          fi



      - name: T1
        if: contains(fromJSON(env.TESTS_ACTIVOS), 'T1')
        id: T1
        uses: classroom-resources/autograding-command-grader@v1
        with:
          test-name: T1
          setup-command: 'cd ${{ steps.carpetas.outputs.exec }}'
          command: >
            cd ${{ steps.carpetas.outputs.exec }} &&
            ${{ steps.carpetas.outputs.test }}/script/g.sh verificar
            "${{ steps.leer.outputs.command }}"
            "${{ steps.carpetas.outputs.test }}/files/t1_inputs.txt"
            "${{ steps.carpetas.outputs.test }}/files/t1_test.txt"
          timeout: 1
          max-score: 1



      - name: T2
        if: contains(fromJSON(env.TESTS_ACTIVOS), 'T2')
        id: T2
        uses: classroom-resources/autograding-command-grader@v1
        with:
          test-name: T2
          setup-command: 'cd ${{ steps.carpetas.outputs.exec }}'
          command: >
            cd ${{ steps.carpetas.outputs.exec }} &&
            ${{ steps.carpetas.outputs.test }}/script/g.sh verificar
            "${{ steps.leer.outputs.command }}"
            "${{ steps.carpetas.outputs.test }}/files/t2_inputs.txt"
            "${{ steps.carpetas.outputs.test }}/files/t2_test.txt"
          timeout: 1
          max-score: 1

  

      - name: T3
        if: contains(fromJSON(env.TESTS_ACTIVOS), 'T3')
        id: T3
        uses: classroom-resources/autograding-command-grader@v1
        with:
          test-name: T3
          setup-command: 'cd ${{ steps.carpetas.outputs.exec }}'
          command: >
            cd ${{ steps.carpetas.outputs.exec }} &&
            ${{ steps.carpetas.outputs.test }}/script/g.sh verificar
            "${{ steps.leer.outputs.command }}"
            "${{ steps.carpetas.outputs.test }}/files/t3_inputs.txt"
            "${{ steps.carpetas.outputs.test }}/files/t3_test.txt"
          timeout: 2
          max-score: 1

      - name: T4
        if: contains(fromJSON(env.TESTS_ACTIVOS), 'T4')
        id: T4
        uses: classroom-resources/autograding-command-grader@v1
        with:
          test-name: T4
          setup-command: 'cd ${{ steps.carpetas.outputs.exec }}'
          command: >
            cd ${{ steps.carpetas.outputs.exec }} &&
            ${{ steps.carpetas.outputs.test }}/script/g.sh verificar
            "${{ steps.leer.outputs.command }}"
            "${{ steps.carpetas.outputs.test }}/files/t4_inputs.txt"
            "${{ steps.carpetas.outputs.test }}/files/t4_test.txt"
          timeout: 2
          max-score: 1

      - name: Construir lista de runners activos
        if: always()
        id: runners
        run: |
          TESTS='${{ env.TESTS_ACTIVOS }}'
          # Convertir ["T1", "T2", "T3"] a "T1, T2, T3"
          RUNNERS=$(echo "$TESTS" | jq -r 'join(", ")')
          echo "list=$RUNNERS" >> $GITHUB_OUTPUT
          echo "‚úÖ Runners activos: $RUNNERS"

      - name: Autograding Reporter
        if: always()
        uses: classroom-resources/autograding-grading-reporter@v1
        env:
            T1_RESULTS: "${{ steps.T1.outcome != 'skipped' && steps.T1.outputs.result || '' }}"
            T2_RESULTS: "${{ steps.T2.outcome != 'skipped' && steps.T2.outputs.result || '' }}"
            T3_RESULTS: "${{ steps.T3.outcome != 'skipped' && steps.T3.outputs.result || '' }}"
            T4_RESULTS: "${{ steps.T4.outcome != 'skipped' && steps.T4.outputs.result || '' }}"

        with:
            runners: ${{ steps.runners.outputs.list }}
